;;Reasoner state and memory
(= (AttentionalFocusMax) 10)
(= (EventsMax) 10)
!(bind! &currentTime (new-state 1))
!(bind! &evidentialBase (new-state 1))
(= (increment $atom) (change-state! $atom (+ 1 (get-state $atom))))
(= (UpdateReasonerState) ((increment &currentTime) (increment &evidentialBase)))
(= (GetReasonerState) ((get-state &currentTime) (Cons (get-state &evidentialBase) Nil)))
!(bind! &belief_events (new-space))
!(bind! &attentional_focus (new-space))
!(bind! &concepts (new-space))

;;Reasoner mechanisms
(= (EventPriorityNow ($T $P) $t) (* $P (/ 1 (+ 1 (- $t $T)))))
(= (ConceptPriorityNow ($T $P) $t) (* $P (/ 1 (+ 1 (- $t $T)))))
(= (StampOverlap Nil) False)
(= (StampOverlap (Cons $LH $LT)) (or (Included $LH $LT) (StampOverlap $LT)))
(= (Eternalize $Ev) (let (Event ($Term $TV) ($Time $Evidence $EPrio)) $Ev
                         (if (== $Time eternal) $Ev
                         (Event ($Term (Truth_Eternalize $TV)) (eternal $Evidence $EPrio)))))
(= (Projection (Event ($Term ($f $c)) ($Time $Evidence $EPrio)) $TargetTime)
   (Event ($Term ($f (* $c (min 1 (/ 1 (abs (- $Time $TargetTime))))))) ($TargetTime $Evidence $EPrio)))
(= (TemporallyAlignedBelief $TaskTime $Belief) (if (== $TaskTime eternal)
                                                   (Eternalize $Belief)
                                                   (Projection $Belief $TaskTime)))
                                    
(= (RevisionAndChoice (Event ($Term1 ($f1 $c1)) (eternal $ev1 $EPrio1)) (Event ($Term2 ($f2 $c2)) (eternal $ev2 $EPrio2)))
   (let $ConclusionStamp (ListConcat $ev1 $ev2) 
    (if (StampOverlap $ConclusionStamp) 
        (if (> $c1 $c2)
            (Event ($Term1 ($f1 $c1)) (eternal $ev1 0.0))
            (Event ($Term2 ($f2 $c2)) (eternal $ev2 0.0)))
        (Event ($Term1 (Truth_Revision ($f1 $c1) ($f2 $c2))) (eternal $ConclusionStamp 0.0)))))

;;revise existing one or create new concept
(= (UpdateConcept $NewEvent $t)
    (let* (((Event ($Term $TV) ($Time $Evidence $EPrio)) $NewEvent)
           ($NewEventEternalized (Eternalize $NewEvent))
           ($MatchConcept (Concept $Term $Belief $BeliefEvent $CPrio)))
    (sequential ((case (match &attentional_focus $MatchConcept $MatchConcept)
                       (($MatchConcept (sequential ((remove-atom &attentional_focus $MatchConcept)
                                                    (let* (($RevisedBelief (RevisionAndChoice $Belief $NewEventEternalized))
                                                           ($MaxPrio (if (> (EventPriorityNow $EPrio $t) (ConceptPriorityNow $CPrio $t))
                                                                            $EPrio $CPrio)))
                                                          (add-atom &attentional_focus (Concept $Term $RevisedBelief $NewEvent $MaxPrio))))))
                   (%void% (case (match &concepts $MatchConcept $MatchConcept)
                                 (($MatchConcept (sequential ((remove-atom &concepts $MatchConcept)
                                                              (add-atom &attentional_focus $MatchConcept)
                                                              (UpdateConcept $NewEvent $t))))
                                  (%void% (add-atom &attentional_focus (Concept $Term $NewEventEternalized $NewEvent $EPrio))))))))))))

(= (ProcessEvent $Ev $t)
   (sequential ((add-atom &belief_events $Ev)
                (UpdateConcept $Ev $t))))

;;The following functions are used to utilize &belief_events as a PQ
(= (BestCandidate $tuple $bestCandidate $evaluateCandidateFunction $t)
  (if (== $tuple ()) 
      $bestCandidate
      (let* (($head (car-atom $tuple))
             ($tail (cdr-atom $tuple)))
        (if (> ($evaluateCandidateFunction $head $t) ($evaluateCandidateFunction $bestCandidate $t))
            (BestCandidate $tail $head $evaluateCandidateFunction $t)
            (BestCandidate $tail $bestCandidate $evaluateCandidateFunction $t)))))
(= (PriorityOf Nil $t)  0.0)
(= (PriorityOf (Event $Sentence ($occT $Ev $Prio)) $t) (EventPriorityNow $Prio $t))
(= (SelectHighestPriorityEvent $baseCandidate $t)
   (let $Evs (collapse (match &belief_events $1 $1)) (BestCandidate $Evs $baseCandidate PriorityOf $t)))

;;making inferences on two events (task from PQ and belief from concept)
(= (ConclusionPriority $EPrio $CPrio $ConcTV) (* (* $EPrio $CPrio) (Truth_Expectation $ConcTV)))
(= (Conclude (Event $S1 ($time1 $ev1 $prio1)) (Event $S2 ($time2 $ev2 $prio2)) $CPrio $t)
   (let $ConclusionStamp (ListConcat $ev1 $ev2) 
        (if (and (not (== $S1 $S2)) (not (StampOverlap $ConclusionStamp)))
            (let ($ConcTerm $ConcTV) (superpose ((|- $S1 $S2) (|- $S2 $S1)))
                 (conclusion (Event ($ConcTerm $ConcTV) 
                            ($time1 $ConclusionStamp ($t (ConclusionPriority (EventPriorityNow $prio1 $t) (ConceptPriorityNow $CPrio $t) $ConcTV))))))
            nop)))

;;find a belief for the task to generate conclusions with
(= (ReasonWithTask (Event $S1 ($time1 $ev1 $prio1)) $t) 
   (let ($Belief $CPrio) (case (get-atoms &attentional_focus)
                               (((Concept $Term (Event $SE2 ($timeE2 $evE2 $prioE2)) (Event $S2 ($time2 $ev2 $prio2)) $CPrio)
                                 (if (and (not (== $time1 eternal)) (> (abs (- $time1 $time2)) 20))
                                     ((Event $SE2 ($timeE2 $evE2 $prioE2)) $Cprio)
                                     ((Event $S2 ($time2 $ev2 $prio2)) $CPrio)))))
        (case (Conclude (Event $S1 ($time1 $ev1 $prio1)) (TemporallyAlignedBelief $time1 $Belief) $CPrio $t)
              (((conclusion $1) (ProcessEvent $1 $t))))))

;;select the highest priority event from the PQ and use it for reasoning
(= (Cycle $t) (let $Ev (SelectHighestPriorityEvent Nil $t) 
                (sequential ((remove-atom &belief_events $Ev)
                             (ReasonWithTask $Ev $t)))))

(= (BoundBeliefEvents $Threshold $Increment $TargetAmount $t)
   (sequential ((let* (($Ev (get-atoms &belief_events))
                       ((Event $Sentence ($Time $Evidence $EPrio)) $Ev))
                      (if (< (EventPriorityNow $EPrio $t) $Threshold) (remove-atom &belief_events $Ev) nop))
                (let $CurrentAmount (TupleCount (collapse (CountElement (get-atoms &belief_events))))
                     (if (and (> $CurrentAmount $TargetAmount) (< $Threshold 1.0))
                         (BoundBeliefEvents (+ $Threshold $Increment) $Increment $TargetAmount $t) nop)))))

(= (BoundConcepts $Threshold $Increment $TargetAmount $t)
   (sequential ((let* (($C (get-atoms &attentional_focus))
                       ((Concept $Term (Event $Sentence $Metadata) $BeliefEvent $CPrio) $C))
                      (if (< (ConceptPriorityNow $CPrio $t) $Threshold) (sequential ((remove-atom &attentional_focus $C)
                                                                                     (add-atom &concepts $C))) nop))
                (let $CurrentAmount (TupleCount (collapse (CountElement (get-atoms &attentional_focus))))
                     (if (and (> $CurrentAmount $TargetAmount) (< $Threshold 1.0))
                         (BoundConcepts (+ $Threshold $Increment) $Increment $TargetAmount $t) nop)))))

;temporal inference with bounded FIFO (sequence and implication formation)
!(bind! &FIFO (new-state Nil))
(= (ListFirstK $C Nil) Nil)
(= (ListFirstK $C (Cons $LH $LT))
   (if (> $C 0)
       (Cons $LH (ListFirstK (- $C 1) $LT))
       Nil))

(= (EventToFIFO $Ev)
   (let $newlist (ListFirstK 3 (Cons $Ev (get-state &FIFO)))
        (change-state! &FIFO $newlist)))

(= (TemporalSequence $Ev1 (Event ($Term2 $Truth2) ($Time2 $Evidence2 $EPrio2)))
   (let (Event ($Term1 $Truth1) ($Time1 $Evidence1 $EPrio1)) (Projection $Ev1 $Time2)
        (Event (($Term1 &/ $Term2) (Truth_Intersection $Truth1 $Truth2)) ($Time2 (ListConcat $Evidence1 $Evidence2) (0 0.0)))))

(= (TemporalImplication $Ev1 (Event ($Term2 $Truth2) ($Time2 $Evidence2 $EPrio2)))
   (let (Event ($Term1 $Truth1) ($Time1 $Evidence1 $EPrio1)) (Projection $Ev1 $Time2)
        (Event (($Term1 =/> $Term2) (Truth_Induction $Truth1 $Truth2)) ($Time2 (ListConcat $Evidence1 $Evidence2) (0 0.0)))))

(= (IsOp (Event ($Term $Truth) $Metadata))
   (case $Term
    (((^ $Opname) True)
      ($Otherwise False))))

(= (TemporalImplicationInduction (Cons $Cons Nil)) nop)
(= (TemporalImplicationInduction (Cons $Cons (Cons $Op (Cons $Prec $Tail))))
   (if (and (IsOp $Op) (and (not (IsOp $Cons)) (not (IsOp $Prec))))
       (let $PrecOp (TemporalSequence $Prec $Op)
            (TemporalImplication $PrecOp $Cons))
       nop))
(= (TemporalImplicationInduction (Cons $Cons (Cons $Prec $Tail)))
   (if (and (not (IsOp $Prec)) (not (IsOp $Cons)))
       (TemporalImplication $Prec $Cons)
       nop))

;;Input procedures
(= (AddBeliefEvent $Sentence)
   (let* ((($t $evidentialBase) (GetReasonerState))
          ($InputEvent (Event $Sentence ($t $evidentialBase ($t 1.0)))))
        (sequential ((EventToFIFO $InputEvent)
                     (let $InducedHypothesis (TemporalImplicationInduction (get-state &FIFO))
                          (if (== $InducedHypothesis nop) nop (ProcessEvent $InducedHypothesis $t)))
                     (ProcessEvent $InputEvent $t)
                     (Cycle $t)
                     (UpdateReasonerState)
                     (if (> $t 1) (BoundBeliefEvents 0.0 0.1 (EventsMax) $t) nop)
                     (if (> $t 1) (BoundConcepts 0.0 0.1 (AttentionalFocusMax) $t) nop)))))
(: EternalQuestion (-> Expression $t))
(= (EternalQuestion $Term) (match (superpose (&attentional_focus &concepts)) (Concept $Term $Belief1 $BeliefEvent1 $CPrio1) $Belief1))
(: EventQuestion (-> Expression $t))
(= (EventQuestion $Term) (match (superpose (&attentional_focus &concepts)) (Concept $Term $Belief1 $BeliefEvent1 $CPrio1) $BeliefEvent1))
